import org.jetbrains.kotlin.konan.properties.Properties
import java.io.File
import java.io.FileInputStream

plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
    id("com.google.dagger.hilt.android")
    id("maven-publish")
    id("signing")
    kotlin("kapt")
}

// This creates a task called `sourcesJar`. It subclasses `Jar`, which is a
// task that knows how to copy files into a .jar file. The block after it is
// called the configuration, which tells the task what it should do when run.
val sourcesJar = tasks.register("sourcesJar", Jar::class) {
    // from() tells the task to take its input files from the argument. In
    // this case, the input is all of our source code files.
    from(android.sourceSets["main"].java.getSourceFiles())

    // archiveClassifier lets us specify that this is an auxiliary file (in
    // addition to the main file we're producing, which is a .aar file). It
    // has the effect of adding -sources at the end of the filename.
    archiveClassifier.set("sources")
}

// This is similar to `sourcesJar`, but we inherit from Javadoc instead which
// is a task that knows how to produce Javadoc HTML from its input files.
val javadoc = tasks.register("javadoc", Javadoc::class) {
    // Self-explanatory, use these files to generate the Javadoc.
    source = android.sourceSets["main"].java.getSourceFiles()

    // We need to include the Android framework classes, otherwise the Javadoc
    // compiler won't be able to find them.
    classpath += project.files(android.bootClasspath)
}

// This takes the Javadoc files generated by `javadoc` and bundles them into
// a single .jar file.
val javadocJar = tasks.register("javadocJar", Jar::class) {
    // All of this should be self-explanatory from the previous tasks.
    dependsOn(javadoc)
    from(javadoc)
    archiveClassifier.set("javadoc")
}

android {
    namespace = "io.github.smmousavi8872.reactiveflow"
    compileSdk = 33

    defaultConfig {
        minSdk = 16

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        consumerProguardFiles("consumer-rules.pro")
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
    kotlinOptions {
        jvmTarget = "1.8"
    }
    kotlin {
        jvmToolchain(8)
    }
}

publishing {
    publications {
        afterEvaluate {
            create<MavenPublication>("maven") {
                // Include all artifacts from the "maven" component. This is the
                // .aar file itself.
                from(components["release"])

                // Include the -sources.jar and -javadoc.jar files that we defined
                // earlier.
                artifact(sourcesJar)

                groupId = "io.github.smmousavi8872.reactiveflow"
                artifactId = "reactive-flow"
                version = "1.0.1.6"

                pom {
                    name.set("ReactiveFlow")
                    packaging = "arr"
                    description.set("A library to mimic the behavior of Rx extension using coroutine SharedFlow")
                    url.set("https://github.com/smmousavi8872/ReactiveFlow")

                    licenses {
                        license {
                            name.set("The Apache License, Version 2.0")
                            url.set("http://www.apache.org/licenses/LICENSE-2.0.txt")
                            distribution.set("repo")
                        }
                    }

                    developers {
                        developer {
                            id.set("smmousavi8872")
                            name.set("Mohsen Mousavi")
                            url.set("https://github.com/smmousavi8872")
                            email.set("s.m.mousavi1993@gmail.com")
                        }
                    }
                    scm {
                        connection.set("scm:git@github.com:smmousavi8872/ReactiveFlow.git")
                        developerConnection.set("scm:git@github.com:smmousavi8872/ReactiveFlow.git")
                        url.set("https://github.com/smmousavi8872/ReactiveFlow/tree/master")
                    }
                }
            }
        }
    }

    repositories {
        maven {
            name = "OSSRH"
            url =
                uri("https://s01.oss.sonatype.org/service/local/staging/deploy/maven2")
            val properties = Properties().apply {
                load(FileInputStream(File(rootProject.rootDir, "local.properties")))
            }
            credentials {
                username = properties.getProperty("mavenCentralUsername")
                password = properties.getProperty("mavenCentralPassword")
            }

        }
    }
}

// Configure the signing plugin.
signing {
    // Use the external gpg binary instead of the built-in PGP library.
    // This lets us use gpg-agent and avoid having to hard-code our PGP key
    // password somewhere.
    //
    // Note that you will need to add this in your ~/.gradle/gradle.properties:
    // signing.gnupg.keyName=<last 8 characters of your PGP key>
    //
    // Additionally, for users who have gpg instead of gpg2:
    // signing.gnupg.useLegacyGpg=true
    useGpgCmd()

    // Since the publication itself was created in `afterEvaluate`, we must
    // do the same here.
    afterEvaluate {
        // This adds a signing stage to the publish task in-place (so we keep
        // using the same task name; it just also performs signing now).
        sign(publishing.publications["maven"])
    }
}

dependencies {
    implementation("androidx.core:core-ktx:1.10.1")
    implementation("androidx.appcompat:appcompat:1.6.1")
    // hilt
    implementation("com.google.dagger:hilt-android:2.47")
    kapt("com.google.dagger:hilt-android-compiler:2.47")
}

// Allow references to generated code
kapt {
    correctErrorTypes = true
}